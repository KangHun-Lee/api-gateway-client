import "./chunk-DC5AMYBS.js";

// node_modules/.pnpm/@primeuix+utils@0.3.2/node_modules/@primeuix/utils/object/index.mjs
function isEmpty(value) {
  return value === null || value === void 0 || value === "" || Array.isArray(value) && value.length === 0 || !(value instanceof Date) && typeof value === "object" && Object.keys(value).length === 0;
}
function isNotEmpty(value) {
  return !isEmpty(value);
}
function isObject(value, empty = true) {
  return value instanceof Object && value.constructor === Object && (empty || Object.keys(value).length !== 0);
}

// node_modules/.pnpm/@primeuix+forms@0.0.2/node_modules/@primeuix/forms/utils/index.mjs
var toValues = (value, name) => {
  if (isObject(value) && value.hasOwnProperty(name)) {
    return value;
  }
  return name ? { [name]: value } : value;
};

// node_modules/.pnpm/@primeuix+forms@0.0.2/node_modules/@primeuix/forms/resolvers/zod/index.mjs
var zodResolver = (schema, schemaOptions, resolverOptions) => async ({ values, name }) => {
  const { sync = false, raw = false } = resolverOptions || {};
  try {
    const result = await schema[sync ? "parse" : "parseAsync"](values, schemaOptions);
    return {
      values: toValues(raw ? values : result, name),
      errors: {}
    };
  } catch (e) {
    if (Array.isArray(e == null ? void 0 : e.errors)) {
      return {
        values: toValues(raw ? values : void 0, name),
        errors: e.errors.reduce((acc, error) => {
          const pathKey = isNotEmpty(error.path) ? error.path[0] : name;
          if (pathKey) {
            acc[pathKey] || (acc[pathKey] = []);
            acc[pathKey].push(error);
          }
          return acc;
        }, {})
      };
    }
    throw e;
  }
};
export {
  zodResolver
};
//# sourceMappingURL=@primevue_forms_resolvers_zod.js.map
